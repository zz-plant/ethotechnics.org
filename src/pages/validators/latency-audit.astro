---
import BaseLayout from "../../layouts/BaseLayout.astro";
import ValidatorMicroDiagram from "../../components/ValidatorMicroDiagram.astro";
import { validatorsContent } from "../../content/validators";

const validatorMeta =
  validatorsContent.validators.find((validator) => validator.id === "VAL-03") ??
  {
    id: "VAL-03",
    standardRef: "STD-01",
    clauseRefs: [],
    mechanismRefs: [],
  };
const siteBase = Astro.site ? Astro.site.toString() : Astro.url.origin;
const breadcrumbItems = [
  { name: "Home", url: new URL("/", siteBase).toString() },
  { name: "Validators", url: new URL("/validators", siteBase).toString() },
  {
    name: "Latency Audit",
    url: new URL("/validators/latency-audit", siteBase).toString(),
  },
];
const validatorMetaJson = JSON.stringify(validatorMeta);
---

<BaseLayout
  title="Latency Audit â€” Validator"
  description="Audit bounded duration compliance against system latency."
  mainClass="page page--wide"
  breadcrumbItems={breadcrumbItems}
>
  <section class="validator">
    <header class="validator__header">
      <div>
        <p class="validator__id">VAL-03</p>
        <h1>Latency Audit</h1>
        <p class="muted">
          Compare declared timeouts against observed latency to test STD-01 Article III.
        </p>
      </div>
      <a class="validator__standard" href="/standards/std-01-temporal-rights">
        Linked standard: STD-01
      </a>
    </header>

    <ValidatorMicroDiagram variant="latency" />

    <form class="validator__form" data-validator-form data-validator-meta={validatorMetaJson}>
      <label class="validator__field">
        Declared timeout (seconds)
        <input
          id="latency-timeout"
          type="number"
          name="timeout"
          min="10"
          value="120"
          required
        />
      </label>
      <label class="validator__field">
        Observed max latency (seconds)
        <input
          id="latency-latency"
          type="number"
          name="latency"
          min="1"
          value="95"
          required
        />
      </label>
      <label class="validator__field">
        Human escalation path in place?
        <select id="latency-escalation" name="escalation">
          <option value="yes" selected>Yes</option>
          <option value="no">No</option>
        </select>
      </label>
      <button class="button primary" type="submit">Generate report card</button>
    </form>

    <div class="validator__report" data-validator-report hidden>
      <div class="validator__status" data-validator-status>
        <span class="status-pill status-pill--green" data-validator-pill>
          Green
        </span>
        <output
          class="validator__status-text"
          data-validator-output
          for="latency-timeout latency-latency latency-escalation"
        >
          Timeouts align with bounded duration.
        </output>
      </div>
      <p class="validator__recommendation">
        Fix this using <a href="/mechanisms/mec-04-hard-clock">MEC-04: The Hard Clock</a>.
      </p>
      <button class="button ghost" type="button" data-validator-download>
        Download JSON
      </button>
    </div>
  </section>
</BaseLayout>

<script>
  const form = document.querySelector<HTMLFormElement>(
    "[data-validator-form]"
  );
  const validatorMeta = form?.dataset.validatorMeta
    ? (JSON.parse(form.dataset.validatorMeta) as {
        id: string;
        standardRef: string;
        clauseRefs: string[];
        mechanismRefs: string[];
      })
    : {
        id: "VAL-03",
        standardRef: "STD-01",
        clauseRefs: [],
        mechanismRefs: [],
      };
  const report = document.querySelector<HTMLElement>(
    "[data-validator-report]"
  );
  const statusPill = document.querySelector<HTMLElement>(
    "[data-validator-pill]"
  );
  const statusOutput = document.querySelector<HTMLOutputElement>(
    "[data-validator-output]"
  );
  const downloadButton = document.querySelector<HTMLButtonElement>(
    "[data-validator-download]"
  );
  const STORAGE_KEY = "validator-latency-audit";

  const updateStatus = (
    level: "red" | "yellow" | "green",
    message: string
  ) => {
    if (!statusPill || !statusOutput) return;
    statusPill.classList.remove(
      "status-pill--red",
      "status-pill--yellow",
      "status-pill--green",
    );
    statusPill.classList.add(`status-pill--${level}`);
    statusPill.textContent = level.charAt(0).toUpperCase() + level.slice(1);
    statusOutput.textContent = message;
  };

  const buildResult = (
    level: "red" | "yellow" | "green",
    message: string,
    inputs: {
      timeout: number;
      latency: number;
      escalation: FormDataEntryValue | null;
    }
  ) => {
    const clauseMap = {
      green: [],
      yellow: validatorMeta.clauseRefs.slice(0, 2),
      red: validatorMeta.clauseRefs,
    };
    const severityMap = {
      green: "low",
      yellow: "medium",
      red: "high",
    };

    return {
      result_id: crypto.randomUUID(),
      generated_at: new Date().toISOString(),
      validator_id: validatorMeta.id,
      standard_id: validatorMeta.standardRef,
      inputs,
      status: level,
      severity: severityMap[level],
      risk_statement: message,
      violated_clauses: clauseMap[level],
      recommended_mechanisms: validatorMeta.mechanismRefs,
      next_actions: [
        `Apply ${validatorMeta.mechanismRefs.join(", ")} safeguards.`,
        "Re-run the validator after remediation.",
      ],
    };
  };

  let latestResult: ReturnType<typeof buildResult> | null = null;

  const saveDraft = () => {
    if (!form || typeof sessionStorage === "undefined") return;
    const data = new FormData(form);
    const payload = Object.fromEntries(data.entries());
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  };

  const restoreDraft = () => {
    if (!form || typeof sessionStorage === "undefined") return;
    const saved = sessionStorage.getItem(STORAGE_KEY);
    if (!saved) return;
    try {
      const parsed = JSON.parse(saved) as Record<string, string>;
      Object.entries(parsed).forEach(([key, value]) => {
        const field = form.elements.namedItem(key);
        if (
          field instanceof HTMLInputElement ||
          field instanceof HTMLSelectElement
        ) {
          field.value = String(value);
        }
      });
    } catch (error) {
      console.error("Unable to restore latency audit draft", error);
    }
  };

  form?.addEventListener("submit", (event) => {
    event.preventDefault();
    if (!form || !report) return;

    if (!form.reportValidity()) {
      const firstInvalid = form.querySelector<HTMLElement>(":invalid");
      firstInvalid?.focus();
      return;
    }

    const data = new FormData(form);
    const timeout = Number(data.get("timeout"));
    const latency = Number(data.get("latency"));
    const escalation = data.get("escalation");
    let level: "red" | "yellow" | "green" = "green";
    let message = "Low risk: bounded duration honored.";

    if (latency > timeout || escalation === "no") {
      level = "red";
      message = "High risk: bounded duration violated.";
    } else if (latency > timeout * 0.8) {
      level = "yellow";
      message = "Medium risk: latency near timeout threshold.";
    } else {
      level = "green";
      message = "Low risk: bounded duration honored.";
    }

    updateStatus(level, message);
    latestResult = buildResult(level, message, { timeout, latency, escalation });
    report.removeAttribute("hidden");
    report.scrollIntoView({ behavior: "smooth", block: "start" });
  });

  downloadButton?.addEventListener("click", () => {
    if (!latestResult) return;
    const blob = new Blob([JSON.stringify(latestResult, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `${validatorMeta.id.toLowerCase()}-result.json`;
    link.click();
    URL.revokeObjectURL(url);
  });

  restoreDraft();
  form?.addEventListener("input", saveDraft);
  form?.addEventListener("blur", saveDraft, true);
</script>
