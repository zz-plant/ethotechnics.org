---
import { getEntry } from "astro:content";
import BaseLayout from "../../layouts/BaseLayout.astro";

export const prerender = true;
import CitationBlock from "../../components/CitationBlock.astro";
import PageIntro from "../../components/PageIntro.astro";
import ScholarlyMeta from "../../components/ScholarlyMeta.astro";
import { glossaryEntryPermalink } from "../../utils/glossary";
import {
  getGlossaryEntryDefaults,
  normalizeGlossaryHeading,
  stripHtml,
} from "../../utils/glossary-helpers";

export async function getStaticPaths() {
  const glossaryEntry = await getEntry("glossary", "glossary");

  if (!glossaryEntry) {
    return [];
  }

  return glossaryEntry.data.categories.flatMap((category) =>
    category.entries.map((entry) => ({
      params: { slug: entry.id },
    })),
  );
}

const { slug } = Astro.params;
const glossaryEntry = (await getEntry("glossary", "glossary"))!;
const libraryEntry = (await getEntry("library", "library"))!;
const { cspNonce } = Astro.locals;
const {
  pageTitle: glossaryTitle,
  pageDescription: glossaryDescription,
  permalink: glossaryPermalink,
  publication,
  categories,
} = glossaryEntry.data;
const entryLabelIndex = new Map(
  categories.flatMap((category) =>
    category.entries.map((entry) => [entry.id, entry.title] as const),
  ),
);
const domainLabels: Record<string, string> = {
  temporal: "Temporal",
  visibility: "Visibility",
  agency: "Agency",
  burden: "Burden",
  patterns: "Patterns",
  measurable: "Measurable",
  structural: "Structural",
  diagnostic: "Diagnostic",
};
const phaseLabels: Record<string, string> = {
  design: "Design",
  deployment: "Deployment",
  audit: "Audit",
  repair: "Repair",
};
const measurabilityLabels: Record<string, string> = {
  qualitative: "Qualitative",
  semi_quantitative: "Semi-quantitative",
  fully_measurable: "Fully measurable",
};
const maturityLabels: Record<string, string> = {
  core_concept: "Core concept",
  active_research: "Active research",
  speculative: "Speculative",
};
const scaleLabels: Record<string, string> = {
  individual: "Individual",
  organizational: "Organizational",
  systemic: "Systemic",
};
const entryRecord = categories
  .flatMap((category) =>
    category.entries.map((entry) => ({
      entry,
      category,
    })),
  )
  .find(({ entry }) => entry.id === slug);

if (!entryRecord) {
  return Astro.response(
    new Response("Glossary entry not found", {
      status: 404,
    }),
  );
}

const { entry, category } = entryRecord;
const categoryLabel = normalizeGlossaryHeading(category.heading);
const pagePermalink = glossaryEntryPermalink(entry.id);
const siteBase = Astro.site ? Astro.site.toString() : Astro.url.origin;
const organizationId = `${siteBase}#organization`;
const websiteId = `${siteBase}#website`;
const pageUrl = Astro.site
  ? new URL(pagePermalink, Astro.site).toString()
  : pagePermalink;
const glossaryUrl = Astro.site
  ? new URL(glossaryPermalink, Astro.site).toString()
  : glossaryPermalink;
const plainDescription = stripHtml(entry.bodyHtml);
const buildMetaDescription = (value: string): string => {
  const sentenceMatch = value.match(/[^.!?]+[.!?]+/);
  const candidate = sentenceMatch ? sentenceMatch[0].trim() : value;

  if (candidate.length <= 180) {
    return candidate;
  }

  return `${candidate.slice(0, 177).trim()}…`;
};
const descriptionBase = `Definition of ${entry.title} in the Ethotechnics glossary (${categoryLabel}). ${plainDescription}`;
const pageDescription = buildMetaDescription(descriptionBase);
const introDescription = `Glossary entry in ${categoryLabel}. Definitions, checks, and evidence for ${entry.title}.`;
const definitionSummary = buildMetaDescription(plainDescription);
const termUpdated = entry.termUpdated ?? publication.updated;
const termVersion = entry.termVersion ?? publication.version;
const termChangelog = entry.termChangelog ?? "/api/changelog.json";
const termUpdatedDate = termUpdated ? termUpdated.split("T")[0] : "TBD";
const {
  scopeText,
  adjacentTerms,
  operationalTests,
  commonCounterfeits,
  minimumEvidence,
  genealogy,
  references,
} = getGlossaryEntryDefaults(entry, category);
const presenceChecks = entry.presenceChecks ?? [];
const missingExpectations = entry.missingExpectations ?? [];
const metaItems = [
  scopeText
    ? { id: "scope", label: "Scope", value: scopeText }
    : undefined,
  genealogy
    ? { id: "genealogy", label: "Genealogy", value: genealogy }
    : undefined,
].filter(
  (
    item,
  ): item is { id: string; label: string; value: string } => Boolean(item),
);
const hasMinimumEvidenceDetails = Boolean(
  minimumEvidence.definition ||
    minimumEvidence.unit ||
    minimumEvidence.dataSource ||
    minimumEvidence.calculation ||
    minimumEvidence.threshold,
);
const minimumEvidenceItems = [
  { label: "Artifact", value: minimumEvidence.artifact },
  { label: "Behavior", value: minimumEvidence.behavior },
  { label: "Metric", value: minimumEvidence.metric },
  { label: "Metric definition", value: minimumEvidence.definition },
  { label: "Metric unit", value: minimumEvidence.unit },
  { label: "Data source", value: minimumEvidence.dataSource },
  { label: "Calculation", value: minimumEvidence.calculation },
  { label: "Threshold", value: minimumEvidence.threshold },
].filter(
  (item): item is { label: string; value: string } => Boolean(item.value),
);
const showMinimumEvidence = hasMinimumEvidenceDetails;
const missingMetadata = [
  !scopeText ? "Scope" : null,
  !genealogy ? "Genealogy" : null,
  operationalTests.length === 0 ? "Operational tests" : null,
  !hasMinimumEvidenceDetails ? "Minimum evidence details" : null,
].filter((item): item is string => Boolean(item));
const domains = entry.domains ?? [];
const phases = entry.phase ?? [];
const measurability = entry.measurability ?? "";
const maturity = entry.maturity ?? "";
const scale = entry.scale ?? "";
const domainPills = domains.map((domain) => domainLabels[domain] ?? domain);
const phaseList = phases.map((phase) => phaseLabels[phase] ?? phase).join(", ");
const metaLine = [
  scale ? `Scale: ${scaleLabels[scale] ?? scale}` : null,
  phases.length ? `Phases: ${phaseList}` : null,
  measurability
    ? `Measurability: ${measurabilityLabels[measurability] ?? measurability}`
    : null,
  maturity
    ? `Maturity: ${maturityLabels[maturity] ?? maturity}`
    : null,
]
  .filter((item): item is string => Boolean(item))
  .join(" · ");
const allEntries = categories.flatMap((category) => category.entries);
const formatClusterLabel = (value: string) =>
  value
    .split("_")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join(" ");
const clusters = entry.clusters ?? [];
const relatedClusters = clusters
  .map((cluster) => ({
    id: cluster,
    label: formatClusterLabel(cluster),
    entries: allEntries
      .filter(
        (candidate) =>
          candidate.id !== entry.id &&
          (candidate.clusters ?? []).includes(cluster),
      )
      .map((candidate) => ({
        id: candidate.id,
        title: candidate.title,
      }))
      .slice(0, 6),
  }))
  .filter((group) => group.entries.length > 0);
const relatedDomains = domains
  .map((domain) => ({
    id: domain,
    label: domainLabels[domain] ?? domain,
    entries: allEntries
      .filter(
        (candidate) =>
          candidate.id !== entry.id &&
          (candidate.domains ?? []).includes(domain),
      )
      .map((candidate) => ({
        id: candidate.id,
        title: candidate.title,
      }))
      .slice(0, 6),
  }))
  .filter((group) => group.entries.length > 0);
const hasRelatedConcepts =
  relatedClusters.length > 0 || relatedDomains.length > 0;
const quickTakeawayLinks = [
  { href: "#definition", label: "Definition" },
  { href: "#presence-checks", label: "Presence checks" },
  { href: "#minimum-evidence", label: "Minimum evidence" },
  { href: "#operational-tests", label: "Operational tests" },
];
const filterParams = Astro.url.searchParams;
const filterBreadcrumbParts = [
  filterParams.get("domains")
    ? `Domains: ${filterParams
        .get("domains")
        ?.split(",")
        .filter(Boolean)
        .map((domain) => domainLabels[domain] ?? domain)
        .join(", ")}`
    : null,
  filterParams.get("phases")
    ? `Phases: ${filterParams
        .get("phases")
        ?.split(",")
        .filter(Boolean)
        .map((phase) => phaseLabels[phase] ?? phase)
        .join(", ")}`
    : null,
  filterParams.get("measurability")
    ? `Measurability: ${filterParams
        .get("measurability")
        ?.split(",")
        .filter(Boolean)
        .map(
          (option) => measurabilityLabels[option] ?? option,
        )
        .join(", ")}`
    : null,
  filterParams.get("status")
    ? `Status: ${filterParams.get("status")}`
    : null,
  filterParams.get("query")
    ? `Query: “${filterParams.get("query")}”`
    : null,
].filter((item): item is string => Boolean(item));
const glossaryFilterUrl = `${glossaryPermalink}${Astro.url.search}`;
const hasFilterBreadcrumb = filterBreadcrumbParts.length > 0;
const patternIndex = new Map(
  libraryEntry.data.patterns.entries.map((pattern) => [pattern.slug, pattern]),
);
const patternFilterLabels = Object.fromEntries(
  libraryEntry.data.patterns.filters.map((filter) => [
    filter.slug,
    filter.label,
  ]),
);
const relatedPatterns = (entry.relatedPatterns ?? [])
  .map((relatedSlug) => {
    const pattern = patternIndex.get(relatedSlug);

    if (!pattern) {
      return null;
    }

    return {
      title: pattern.title,
      href: `/mechanisms/patterns/${pattern.slug}`,
      filterLabels: pattern.filters.map(
        (filter) => patternFilterLabels[filter] ?? filter,
      ),
    };
  })
  .filter(
    (
      pattern,
    ): pattern is { title: string; href: string; filterLabels: string[] } =>
      Boolean(pattern),
  );
const anchorLinks = [
  { href: "#definition", label: "Definition" },
  ...(scopeText ? [{ href: "#scope", label: "Scope" }] : []),
  ...(adjacentTerms.length
    ? [{ href: "#adjacent-terms", label: "Adjacent terms" }]
    : []),
  ...(hasRelatedConcepts
    ? [{ href: "#related-concepts", label: "Related concepts" }]
    : []),
  ...(presenceChecks.length
    ? [{ href: "#presence-checks", label: "Presence checks" }]
    : []),
  ...(missingExpectations.length
    ? [{ href: "#missing-expectations", label: "Missing expectations" }]
    : []),
  ...(operationalTests.length
    ? [{ href: "#operational-tests", label: "Operational tests" }]
    : []),
  ...(showMinimumEvidence
    ? [{ href: "#minimum-evidence", label: "Minimum evidence" }]
    : []),
  ...(genealogy ? [{ href: "#genealogy", label: "Genealogy" }] : []),
  ...(relatedPatterns.length
    ? [{ href: "#related-mechanisms", label: "Related mechanisms" }]
    : []),
  ...(entry.examples?.length
    ? [{ href: "#example-corpus", label: "Example corpus" }]
    : []),
  ...(references.length ? [{ href: "#references", label: "References" }] : []),
];
const structuredData = {
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebPage",
      "@id": pageUrl,
      name: `${entry.title} — Ethotechnics glossary`,
      description: pageDescription,
      url: pageUrl,
      isPartOf: {
        "@id": websiteId,
      },
      publisher: {
        "@id": organizationId,
      },
      mainEntity: {
        "@id": `${pageUrl}#defined-term`,
      },
    },
    {
      "@type": "DefinedTerm",
      "@id": `${pageUrl}#defined-term`,
      name: entry.title,
      description: plainDescription,
      url: pageUrl,
      inDefinedTermSet: {
        "@type": "DefinedTermSet",
        name: glossaryTitle,
        description: glossaryDescription,
        url: glossaryUrl,
      },
    },
    {
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: "Home",
          item: Astro.site ? new URL("/", Astro.site).toString() : "/",
        },
        {
          "@type": "ListItem",
          position: 2,
          name: "Glossary",
          item: glossaryUrl,
        },
        {
          "@type": "ListItem",
          position: 3,
          name: entry.title,
          item: pageUrl,
        },
      ],
    },
  ],
};
const structuredDataJson = JSON.stringify(structuredData, null, 2);
---

<BaseLayout
  title={`${entry.title} — Ethotechnics glossary`}
  description={pageDescription}
  enableGlossaryHighlights={false}
>
  <PageIntro
    eyebrow="Glossary entry"
    title={entry.title}
    description={introDescription}
    permalink={pagePermalink}
    anchorLinks={anchorLinks}
    panelCopy={{
      eyebrow: "Glossary index",
      title: "Return to the glossary index.",
      description: `Explore ${categories.length} glossary territories and search ${entryLabelIndex.size} terms from one place.`,
      link: { label: "Browse the glossary", href: glossaryPermalink },
    }}
  />
  <div class="callout glossary-entry__summary">
    <p class="eyebrow">Quick takeaways</p>
    <p class="muted">{definitionSummary}</p>
    <ul class="pill-list pill-list--wrap glossary-entry__summary-links">
      {quickTakeawayLinks.map((link) => (
        <li>
          <a class="pill-list__button" href={link.href}>
            {link.label}
          </a>
        </li>
      ))}
    </ul>
  </div>
  <article
    class="glossary-entry glossary-entry--detail"
    itemscope
    itemtype="https://schema.org/DefinedTerm"
  >
    <meta itemprop="name" content={entry.title} />
    <meta itemprop="url" content={pageUrl} />
    <meta itemprop="inDefinedTermSet" content={glossaryUrl} />
    {hasFilterBreadcrumb && (
      <nav class="glossary-entry__breadcrumb" aria-label="Glossary breadcrumbs">
        <a href={glossaryFilterUrl}>Glossary</a>
        <span class="glossary-entry__breadcrumb-divider">/</span>
        <span class="muted">
          Filtered by: {filterBreadcrumbParts.join(" · ")}
        </span>
      </nav>
    )}
    <header id="definition" class="glossary-entry__hero">
      <div class="glossary-entry__hero-copy">
        <p class="eyebrow">Definition</p>
        <div
          class="glossary-entry__body"
          set:html={entry.bodyHtml}
          itemprop="description"
        />
        {(domainPills.length > 0 || metaLine) && (
          <div class="glossary-entry__tagline">
            {domainPills.length > 0 && (
              <div class="pill-row">
                {domainPills.map((domain) => (
                  <span class="pill pill--ghost">{domain}</span>
                ))}
              </div>
            )}
            {metaLine && <p class="muted small">{metaLine}</p>}
          </div>
        )}
      </div>
      {metaItems.length > 0 && (
        <dl class="glossary-entry__meta">
          {metaItems.map((item) => (
            <>
              <dt id={item.id} class="glossary-entry__meta-term eyebrow">
                {item.label}
              </dt>
              <dd class="glossary-entry__meta-definition muted">
                {item.value}
              </dd>
            </>
          ))}
        </dl>
      )}
    </header>
    <div class="glossary-entry__layout">
      <div class="glossary-entry__main">
        {
          adjacentTerms.length > 0 && (
            <section id="adjacent-terms" class="glossary-entry__section">
              <p class="eyebrow">Adjacent terms</p>
              <div class="pill-row">
                {adjacentTerms.map((term) => (
                  <a
                    class="pill pill--muted"
                    href={glossaryEntryPermalink(term)}
                    itemprop="keywords"
                  >
                    {entryLabelIndex.get(term) ?? term}
                  </a>
                ))}
              </div>
            </section>
          )
        }
        {hasRelatedConcepts && (
          <section id="related-concepts" class="glossary-entry__section">
            <p class="eyebrow">Related concepts</p>
            {relatedClusters.map((group) => (
              <div class="glossary-entry__related-group">
                <p class="muted small">
                  Part of cluster: <strong>{group.label}</strong>
                </p>
                <div class="pill-row">
                  {group.entries.map((term) => (
                    <a
                      class="pill pill--muted"
                      href={glossaryEntryPermalink(term.id)}
                    >
                      {term.title}
                    </a>
                  ))}
                </div>
              </div>
            ))}
            {relatedDomains.map((group) => (
              <div class="glossary-entry__related-group">
                <p class="muted small">
                  Also tagged: <strong>{group.label}</strong>
                </p>
                <div class="pill-row">
                  {group.entries.map((term) => (
                    <a
                      class="pill pill--muted"
                      href={glossaryEntryPermalink(term.id)}
                    >
                      {term.title}
                    </a>
                  ))}
                </div>
              </div>
            ))}
          </section>
        )}
        {
          (presenceChecks.length > 0 || missingExpectations.length > 0) && (
            <section class="glossary-entry__section glossary-entry__section--checks">
              {presenceChecks.length > 0 && (
                <div id="presence-checks" class="glossary-entry__check">
                  <p class="eyebrow">If this is present, check for</p>
                  <p class="muted small">
                    Signals and companion artifacts to verify when this term
                    shows up.
                  </p>
                  <ul class="muted">
                    {presenceChecks.map((term) => (
                      <li>
                        <a href={glossaryEntryPermalink(term)}>
                          {entryLabelIndex.get(term) ?? term}
                        </a>
                      </li>
                    ))}
                  </ul>
                </div>
              )}
              {missingExpectations.length > 0 && (
                <div id="missing-expectations" class="glossary-entry__check">
                  <p class="eyebrow">If this is missing, expect</p>
                  <p class="muted small">
                    Outcomes to watch for when this capability is absent.
                  </p>
                  <ul class="muted">
                    {missingExpectations.map((term) => (
                      <li>
                        <a href={glossaryEntryPermalink(term)}>
                          {entryLabelIndex.get(term) ?? term}
                        </a>
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </section>
          )
        }
        {
          entry.examples && entry.examples.length > 0 && (
            <section id="example-corpus" class="glossary-entry__section">
              <p class="eyebrow">Example corpus</p>
              <ul class="muted">
                {entry.examples.map((example) => (
                  <li>{example}</li>
                ))}
              </ul>
            </section>
          )
        }
        {
          references.length > 0 && (
            <section id="references" class="glossary-entry__section">
              <p class="eyebrow">References</p>
              <ul class="muted glossary-entry__resources">
                {references.map((resource) => (
                  <li>
                    <a href={resource.href}>{resource.label}</a>
                    {resource.type && (
                      <span class="muted"> · {resource.type}</span>
                    )}
                  </li>
                ))}
              </ul>
            </section>
          )
        }
      </div>
      <aside class="glossary-entry__sidebar">
        {category.descriptionHtml && (
          <section class="glossary-entry__section">
            <p class="eyebrow">Glossary territory</p>
            <div class="glossary-entry__body" set:html={category.descriptionHtml} />
            <p class="muted small">
              Explore {categoryLabel} in the{" "}
              <a href={glossaryPermalink}>glossary index</a>.
            </p>
          </section>
        )}
        <section class="glossary-entry__section">
          <p class="eyebrow">Entry details</p>
          <ul class="muted">
            <li>Last updated: {termUpdatedDate}</li>
            <li>Term version: {termVersion}</li>
            <li>
              Changelog: <a href={termChangelog}>View updates</a>
            </li>
          </ul>
        </section>
        {operationalTests.length > 0 && (
          <section id="operational-tests" class="glossary-entry__section">
            <p class="eyebrow">Operational tests</p>
            <ul class="muted">
              {operationalTests.map((test) => (
                <li>{test}</li>
              ))}
            </ul>
          </section>
        )}
        {
          commonCounterfeits.length > 0 && (
            <section id="common-counterfeits" class="glossary-entry__section">
              <p class="eyebrow">Common counterfeits</p>
              <ul class="muted">
                {commonCounterfeits.map((counterfeit) => (
                  <li>{counterfeit}</li>
                ))}
              </ul>
            </section>
          )
        }
        {showMinimumEvidence && (
          <section id="minimum-evidence" class="glossary-entry__section">
            <p class="eyebrow">Minimum evidence</p>
            <ul class="muted">
              {minimumEvidenceItems.map((item) => (
                <li>
                  <strong>{item.label}:</strong> {item.value}
                </li>
              ))}
            </ul>
          </section>
        )}
        {missingMetadata.length > 0 && (
          <div class="callout">
            <p class="eyebrow">Entry completeness</p>
            <h3>Additional term details are in progress.</h3>
            <ul class="muted">
              {missingMetadata.map((item) => (
                <li>{item}</li>
              ))}
            </ul>
          </div>
        )}
        {
          relatedPatterns.length > 0 && (
            <section
              id="related-mechanisms"
              class="glossary-entry__section glossary-entry__section--patterns"
            >
              <p class="eyebrow">Related mechanisms</p>
              <ul class="glossary-entry__patterns-list">
                {relatedPatterns.map((relatedPattern) => (
                  <li class="glossary-entry__pattern-card">
                    <a
                      class="glossary-entry__pattern-link"
                      href={relatedPattern.href}
                    >
                      <span class="glossary-entry__pattern-title">
                        {relatedPattern.title}
                      </span>
                      <span class="muted small">
                        {relatedPattern.filterLabels.join(", ")}
                      </span>
                    </a>
                  </li>
                ))}
              </ul>
              <p class="muted small glossary-entry__patterns-hint">
                See the full mechanisms catalog.
              </p>
            </section>
          )
        }
      </aside>
    </div>
  </article>

  <CitationBlock
    title={entry.title}
    permalink={pagePermalink}
    publication={publication}
    publisher="Ethotechnics glossary"
    citationKey={`glossary_${entry.id}`}
    summaryLabel="Cite this glossary entry"
  />
  <ScholarlyMeta publication={publication} permalink={pagePermalink} />

  <script
    type="application/ld+json"
    nonce={cspNonce}
    set:html={structuredDataJson}
    is:inline
  />
</BaseLayout>
