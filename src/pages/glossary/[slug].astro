---
import { getEntry } from "astro:content";
import BaseLayout from "../../layouts/BaseLayout.astro";

export const prerender = true;
import CitationBlock from "../../components/CitationBlock.astro";
import PageIntro from "../../components/PageIntro.astro";
import ScholarlyMeta from "../../components/ScholarlyMeta.astro";
import { glossaryEntryPermalink } from "../../utils/glossary";
import {
  getGlossaryEntryDefaults,
  normalizeGlossaryHeading,
  stripHtml,
} from "../../utils/glossary-helpers";

export async function getStaticPaths() {
  const glossaryEntry = await getEntry("glossary", "glossary");

  if (!glossaryEntry) {
    return [];
  }

  return glossaryEntry.data.categories.flatMap((category) =>
    category.entries.map((entry) => ({
      params: { slug: entry.id },
    })),
  );
}

const { slug } = Astro.params;
const glossaryEntry = (await getEntry("glossary", "glossary"))!;
const libraryEntry = (await getEntry("library", "library"))!;
const {
  pageTitle: glossaryTitle,
  pageDescription: glossaryDescription,
  permalink: glossaryPermalink,
  publication,
  categories,
} = glossaryEntry.data;
const entryLabelIndex = new Map(
  categories.flatMap((category) =>
    category.entries.map((entry) => [entry.id, entry.title] as const),
  ),
);
const entryRecord = categories
  .flatMap((category) =>
    category.entries.map((entry) => ({
      entry,
      category,
    })),
  )
  .find(({ entry }) => entry.id === slug);

if (!entryRecord) {
  return Astro.response(
    new Response("Glossary entry not found", {
      status: 404,
    }),
  );
}

const { entry, category } = entryRecord;
const categoryLabel = normalizeGlossaryHeading(category.heading);
const pagePermalink = glossaryEntryPermalink(entry.id);
const pageUrl = Astro.site
  ? new URL(pagePermalink, Astro.site).toString()
  : pagePermalink;
const glossaryUrl = Astro.site
  ? new URL(glossaryPermalink, Astro.site).toString()
  : glossaryPermalink;
const plainDescription = stripHtml(entry.bodyHtml);
const buildMetaDescription = (value: string): string => {
  const sentenceMatch = value.match(/[^.!?]+[.!?]+/);
  const candidate = sentenceMatch ? sentenceMatch[0].trim() : value;

  if (candidate.length <= 180) {
    return candidate;
  }

  return `${candidate.slice(0, 177).trim()}…`;
};
const descriptionBase = `Definition of ${entry.title} in the Ethotechnics glossary (${categoryLabel}). ${plainDescription}`;
const pageDescription = buildMetaDescription(descriptionBase);
const introDescription = `Glossary entry in ${categoryLabel}. Definitions, checks, and evidence for ${entry.title}.`;
const termUpdated = entry.termUpdated ?? publication.updated;
const termVersion = entry.termVersion ?? publication.version;
const termChangelog = entry.termChangelog ?? "/api/changelog.json";
const termUpdatedDate = termUpdated ? termUpdated.split("T")[0] : "TBD";
const {
  scopeText,
  adjacentTerms,
  operationalTests,
  commonCounterfeits,
  minimumEvidence,
  genealogy,
  references,
} = getGlossaryEntryDefaults(entry, category);
const presenceChecks = entry.presenceChecks ?? [];
const missingExpectations = entry.missingExpectations ?? [];
const metaItems = [
  scopeText
    ? { id: "scope", label: "Scope", value: scopeText }
    : undefined,
  genealogy
    ? { id: "genealogy", label: "Genealogy", value: genealogy }
    : undefined,
].filter(
  (
    item,
  ): item is { id: string; label: string; value: string } => Boolean(item),
);
const hasMinimumEvidenceDetails = Boolean(
  minimumEvidence.definition ||
    minimumEvidence.unit ||
    minimumEvidence.dataSource ||
    minimumEvidence.calculation ||
    minimumEvidence.threshold,
);
const minimumEvidenceItems = [
  { label: "Artifact", value: minimumEvidence.artifact },
  { label: "Behavior", value: minimumEvidence.behavior },
  { label: "Metric", value: minimumEvidence.metric },
  { label: "Metric definition", value: minimumEvidence.definition },
  { label: "Metric unit", value: minimumEvidence.unit },
  { label: "Data source", value: minimumEvidence.dataSource },
  { label: "Calculation", value: minimumEvidence.calculation },
  { label: "Threshold", value: minimumEvidence.threshold },
].filter(
  (item): item is { label: string; value: string } => Boolean(item.value),
);
const showMinimumEvidence = hasMinimumEvidenceDetails;
const missingMetadata = [
  !scopeText ? "Scope" : null,
  !genealogy ? "Genealogy" : null,
  operationalTests.length === 0 ? "Operational tests" : null,
  !hasMinimumEvidenceDetails ? "Minimum evidence details" : null,
].filter((item): item is string => Boolean(item));
const patternIndex = new Map(
  libraryEntry.data.patterns.entries.map((pattern) => [pattern.slug, pattern]),
);
const patternFilterLabels = Object.fromEntries(
  libraryEntry.data.patterns.filters.map((filter) => [
    filter.slug,
    filter.label,
  ]),
);
const relatedPatterns = (entry.relatedPatterns ?? [])
  .map((relatedSlug) => {
    const pattern = patternIndex.get(relatedSlug);

    if (!pattern) {
      return null;
    }

    return {
      title: pattern.title,
      href: `/mechanisms/patterns/${pattern.slug}`,
      filterLabels: pattern.filters.map(
        (filter) => patternFilterLabels[filter] ?? filter,
      ),
    };
  })
  .filter(
    (
      pattern,
    ): pattern is { title: string; href: string; filterLabels: string[] } =>
      Boolean(pattern),
  );
const anchorLinks = [
  { href: "#definition", label: "Definition" },
  ...(scopeText ? [{ href: "#scope", label: "Scope" }] : []),
  ...(adjacentTerms.length
    ? [{ href: "#adjacent-terms", label: "Adjacent terms" }]
    : []),
  ...(presenceChecks.length
    ? [{ href: "#presence-checks", label: "Presence checks" }]
    : []),
  ...(missingExpectations.length
    ? [{ href: "#missing-expectations", label: "Missing expectations" }]
    : []),
  ...(operationalTests.length
    ? [{ href: "#operational-tests", label: "Operational tests" }]
    : []),
  ...(showMinimumEvidence
    ? [{ href: "#minimum-evidence", label: "Minimum evidence" }]
    : []),
  ...(genealogy ? [{ href: "#genealogy", label: "Genealogy" }] : []),
  ...(relatedPatterns.length
    ? [{ href: "#related-mechanisms", label: "Related mechanisms" }]
    : []),
  ...(entry.examples?.length
    ? [{ href: "#example-corpus", label: "Example corpus" }]
    : []),
  ...(references.length ? [{ href: "#references", label: "References" }] : []),
];
const structuredData = {
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "WebPage",
      "@id": pageUrl,
      name: `${entry.title} — Ethotechnics glossary`,
      description: pageDescription,
      url: pageUrl,
      mainEntity: {
        "@id": `${pageUrl}#defined-term`,
      },
    },
    {
      "@type": "DefinedTerm",
      "@id": `${pageUrl}#defined-term`,
      name: entry.title,
      description: plainDescription,
      url: pageUrl,
      inDefinedTermSet: {
        "@type": "DefinedTermSet",
        name: glossaryTitle,
        description: glossaryDescription,
        url: glossaryUrl,
      },
    },
    {
      "@type": "BreadcrumbList",
      itemListElement: [
        {
          "@type": "ListItem",
          position: 1,
          name: "Home",
          item: Astro.site ? new URL("/", Astro.site).toString() : "/",
        },
        {
          "@type": "ListItem",
          position: 2,
          name: "Glossary",
          item: glossaryUrl,
        },
        {
          "@type": "ListItem",
          position: 3,
          name: entry.title,
          item: pageUrl,
        },
      ],
    },
  ],
};
const structuredDataJson = JSON.stringify(structuredData, null, 2);
---

<BaseLayout
  title={`${entry.title} — Ethotechnics glossary`}
  description={pageDescription}
  enableGlossaryHighlights={false}
>
  <PageIntro
    eyebrow="Glossary entry"
    title={entry.title}
    description={introDescription}
    permalink={pagePermalink}
    anchorLinks={anchorLinks}
    panelCopy={{
      eyebrow: "Glossary index",
      title: "Return to the glossary index.",
      description: `Explore ${categories.length} glossary territories and search ${entryLabelIndex.size} terms from one place.`,
      link: { label: "Browse the glossary", href: glossaryPermalink },
    }}
  />
  <article
    class="glossary-entry glossary-entry--detail"
    itemscope
    itemtype="https://schema.org/DefinedTerm"
  >
    <meta itemprop="name" content={entry.title} />
    <meta itemprop="url" content={pageUrl} />
    <meta itemprop="inDefinedTermSet" content={glossaryUrl} />
    <header id="definition" class="glossary-entry__hero">
      <div class="glossary-entry__hero-copy">
        <p class="eyebrow">Definition</p>
        <div
          class="glossary-entry__body"
          set:html={entry.bodyHtml}
          itemprop="description"
        />
      </div>
      {metaItems.length > 0 && (
        <dl class="glossary-entry__meta">
          {metaItems.map((item) => (
            <>
              <dt id={item.id} class="glossary-entry__meta-term eyebrow">
                {item.label}
              </dt>
              <dd class="glossary-entry__meta-definition muted">
                {item.value}
              </dd>
            </>
          ))}
        </dl>
      )}
    </header>
    <div class="glossary-entry__layout">
      <div class="glossary-entry__main">
        {
          adjacentTerms.length > 0 && (
            <section id="adjacent-terms" class="glossary-entry__section">
              <p class="eyebrow">Adjacent terms</p>
              <div class="pill-row">
                {adjacentTerms.map((term) => (
                  <a
                    class="pill pill--muted"
                    href={glossaryEntryPermalink(term)}
                    itemprop="keywords"
                  >
                    {entryLabelIndex.get(term) ?? term}
                  </a>
                ))}
              </div>
            </section>
          )
        }
        {
          (presenceChecks.length > 0 || missingExpectations.length > 0) && (
            <section class="glossary-entry__section glossary-entry__section--checks">
              {presenceChecks.length > 0 && (
                <div id="presence-checks" class="glossary-entry__check">
                  <p class="eyebrow">If this is present, check for</p>
                  <p class="muted small">
                    Signals and companion artifacts to verify when this term
                    shows up.
                  </p>
                  <ul class="muted">
                    {presenceChecks.map((term) => (
                      <li>
                        <a href={glossaryEntryPermalink(term)}>
                          {entryLabelIndex.get(term) ?? term}
                        </a>
                      </li>
                    ))}
                  </ul>
                </div>
              )}
              {missingExpectations.length > 0 && (
                <div id="missing-expectations" class="glossary-entry__check">
                  <p class="eyebrow">If this is missing, expect</p>
                  <p class="muted small">
                    Outcomes to watch for when this capability is absent.
                  </p>
                  <ul class="muted">
                    {missingExpectations.map((term) => (
                      <li>
                        <a href={glossaryEntryPermalink(term)}>
                          {entryLabelIndex.get(term) ?? term}
                        </a>
                      </li>
                    ))}
                  </ul>
                </div>
              )}
            </section>
          )
        }
        {
          entry.examples && entry.examples.length > 0 && (
            <section id="example-corpus" class="glossary-entry__section">
              <p class="eyebrow">Example corpus</p>
              <ul class="muted">
                {entry.examples.map((example) => (
                  <li>{example}</li>
                ))}
              </ul>
            </section>
          )
        }
        {
          references.length > 0 && (
            <section id="references" class="glossary-entry__section">
              <p class="eyebrow">References</p>
              <ul class="muted glossary-entry__resources">
                {references.map((resource) => (
                  <li>
                    <a href={resource.href}>{resource.label}</a>
                    {resource.type && (
                      <span class="muted"> · {resource.type}</span>
                    )}
                  </li>
                ))}
              </ul>
            </section>
          )
        }
      </div>
      <aside class="glossary-entry__sidebar">
        {category.descriptionHtml && (
          <section class="glossary-entry__section">
            <p class="eyebrow">Glossary territory</p>
            <div class="glossary-entry__body" set:html={category.descriptionHtml} />
            <p class="muted small">
              Explore {categoryLabel} in the{" "}
              <a href={glossaryPermalink}>glossary index</a>.
            </p>
          </section>
        )}
        <section class="glossary-entry__section">
          <p class="eyebrow">Entry details</p>
          <ul class="muted">
            <li>Last updated: {termUpdatedDate}</li>
            <li>Term version: {termVersion}</li>
            <li>
              Changelog: <a href={termChangelog}>View updates</a>
            </li>
          </ul>
        </section>
        {operationalTests.length > 0 && (
          <section id="operational-tests" class="glossary-entry__section">
            <p class="eyebrow">Operational tests</p>
            <ul class="muted">
              {operationalTests.map((test) => (
                <li>{test}</li>
              ))}
            </ul>
          </section>
        )}
        {
          commonCounterfeits.length > 0 && (
            <section id="common-counterfeits" class="glossary-entry__section">
              <p class="eyebrow">Common counterfeits</p>
              <ul class="muted">
                {commonCounterfeits.map((counterfeit) => (
                  <li>{counterfeit}</li>
                ))}
              </ul>
            </section>
          )
        }
        {showMinimumEvidence && (
          <section id="minimum-evidence" class="glossary-entry__section">
            <p class="eyebrow">Minimum evidence</p>
            <ul class="muted">
              {minimumEvidenceItems.map((item) => (
                <li>
                  <strong>{item.label}:</strong> {item.value}
                </li>
              ))}
            </ul>
          </section>
        )}
        {missingMetadata.length > 0 && (
          <div class="callout">
            <p class="eyebrow">Entry completeness</p>
            <h3>Additional term details are in progress.</h3>
            <ul class="muted">
              {missingMetadata.map((item) => (
                <li>{item}</li>
              ))}
            </ul>
          </div>
        )}
        {
          relatedPatterns.length > 0 && (
            <section
              id="related-mechanisms"
              class="glossary-entry__section glossary-entry__section--patterns"
            >
              <p class="eyebrow">Related mechanisms</p>
              <ul class="glossary-entry__patterns-list">
                {relatedPatterns.map((relatedPattern) => (
                  <li class="glossary-entry__pattern-card">
                    <a
                      class="glossary-entry__pattern-link"
                      href={relatedPattern.href}
                    >
                      <span class="glossary-entry__pattern-title">
                        {relatedPattern.title}
                      </span>
                      <span class="muted small">
                        {relatedPattern.filterLabels.join(", ")}
                      </span>
                    </a>
                  </li>
                ))}
              </ul>
              <p class="muted small glossary-entry__patterns-hint">
                See the full mechanisms catalog.
              </p>
            </section>
          )
        }
      </aside>
    </div>
  </article>

  <CitationBlock
    title={entry.title}
    permalink={pagePermalink}
    publication={publication}
    publisher="Ethotechnics glossary"
    citationKey={`glossary_${entry.id}`}
    summaryLabel="Cite this glossary entry"
  />
  <ScholarlyMeta publication={publication} permalink={pagePermalink} />

  <script type="application/ld+json" set:html={structuredDataJson} is:inline />
</BaseLayout>
