---
import BaseLayout from "../../layouts/BaseLayout.astro";
import CitationBlock from "../../components/CitationBlock.astro";
import PageIntro from "../../components/PageIntro.astro";
import ScholarlyMeta from "../../components/ScholarlyMeta.astro";
import SectionBlock from "../../components/SectionBlock.astro";

const pageTitle = "STD-01 rights \u2192 validators \u2192 mechanisms matrix";
const pageDescription =
  "A reference matrix linking STD-01 temporal rights to validator coverage and enforcement mechanisms.";
const permalink = "/standards/std-01-rights-matrix";
const anchorLinks = [
  { href: "#matrix", label: "Matrix" },
  { href: "#notes", label: "Coverage notes" },
  { href: "#citations", label: "Citations" },
];

const slugify = (value: string) =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");

const publication = {
  authors: [
    {
      name: "Ethotechnics Standards Working Group",
      affiliation: "Ethotechnics Institute",
      email: "standards@ethotechnics.org",
    },
  ],
  contact: "standards@ethotechnics.org",
  published: "2026-03-01T00:00:00Z",
  updated: "2026-03-01T00:00:00Z",
  version: "v1.0.0",
  doi: "Pending Zenodo deposit",
  archiveUrl: `https://web.archive.org/save/https://ethotechnics.org${permalink}`,
  changelog: [
    {
      version: "v1.0.0",
      date: "2026-03-01",
      summary:
        "Published the first crosswalk of STD-01 rights, validator coverage, and mechanisms.",
    },
  ],
  license: {
    label: "CC BY 4.0",
    href: "https://creativecommons.org/licenses/by/4.0/",
  },
  attribution:
    "Credit Ethotechnics Institute Standards Working Group, include the page title + version, and link to the canonical permalink.",
};

const matrix = [
  {
    right: "Stoppability (STD-01 \u00a71)",
    validators: [
      { label: "VAL-01 Burden Modeler", href: "/validators/burden-modeler" },
      { label: "VAL-02 Risk Radar", href: "/validators/risk-radar" },
    ],
    mechanisms: [
      { label: "MEC-05 Kill switch", href: "/mechanisms/patterns/kill-switch" },
      { label: "MEC-01 Decision log with dissent", href: "/mechanisms/patterns/decision-log" },
    ],
    notes: "Use halt controls plus decision logging to make stoppability enforceable.",
  },
  {
    right: "Exit / Resignation (STD-01 \u00a72)",
    validators: [
      { label: "VAL-01 Burden Modeler", href: "/validators/burden-modeler" },
      { label: "VAL-02 Risk Radar", href: "/validators/risk-radar" },
    ],
    mechanisms: [
      { label: "MEC-02 Progressive consent", href: "/mechanisms/patterns/progressive-consent" },
      { label: "MEC-06 Appeal paths", href: "/mechanisms/patterns/appeal-paths" },
    ],
    notes: "Model time-to-exit and enforce clear resignation paths in the UI.",
  },
  {
    right: "Bounded duration (STD-01 \u00a73)",
    validators: [
      { label: "VAL-03 Latency Audit", href: "/validators/latency-audit" },
    ],
    mechanisms: [
      { label: "MEC-04 Hard Clock", href: "/mechanisms/mec-04-hard-clock" },
      { label: "MEC-03 Maintenance windowing", href: "/mechanisms/patterns/maintenance-windowing" },
    ],
    notes: "Every state needs a deadline, escalation path, and declared window.",
  },
  {
    right: "Reversibility (STD-01 \u00a74)",
    validators: [
      { label: "VAL-01 Burden Modeler", href: "/validators/burden-modeler" },
      { label: "VAL-02 Risk Radar", href: "/validators/risk-radar" },
    ],
    mechanisms: [
      { label: "MEC-02 Progressive consent", href: "/mechanisms/patterns/progressive-consent" },
      { label: "MEC-01 Decision log with dissent", href: "/mechanisms/patterns/decision-log" },
    ],
    notes: "Guard irreversible actions with rollback windows and decision traceability.",
  },
  {
    right: "Non-coercive waiting (STD-01 \u00a75)",
    validators: [
      { label: "VAL-03 Latency Audit", href: "/validators/latency-audit" },
      { label: "VAL-01 Burden Modeler", href: "/validators/burden-modeler" },
    ],
    mechanisms: [
      { label: "MEC-03 Maintenance windowing", href: "/mechanisms/patterns/maintenance-windowing" },
      { label: "MEC-02 Progressive consent", href: "/mechanisms/patterns/progressive-consent" },
    ],
    notes: "Expose wait-time truth and provide alternate paths for long delays.",
  },
  {
    right: "Human override (STD-01 \u00a76)",
    validators: [
      { label: "VAL-02 Risk Radar", href: "/validators/risk-radar" },
      { label: "VAL-01 Burden Modeler", href: "/validators/burden-modeler" },
    ],
    mechanisms: [
      { label: "MEC-06 Appeal paths", href: "/mechanisms/patterns/appeal-paths" },
      { label: "MEC-01 Decision log with dissent", href: "/mechanisms/patterns/decision-log" },
    ],
    notes: "Ensure escalations route to accountable humans with visible ownership.",
  },
  {
    right: "Transparent burden (STD-01 \u00a77)",
    validators: [
      { label: "VAL-01 Burden Modeler", href: "/validators/burden-modeler" },
      { label: "VAL-02 Risk Radar", href: "/validators/risk-radar" },
    ],
    mechanisms: [
      { label: "MEC-01 Decision log with dissent", href: "/mechanisms/patterns/decision-log" },
      { label: "MEC-03 Maintenance windowing", href: "/mechanisms/patterns/maintenance-windowing" },
    ],
    notes: "Publish time tax metrics and bind remediation to logged decisions.",
  },
];

const rights = matrix.map((row) => {
  const slug = slugify(row.right);
  return {
    label: row.right,
    slug,
    id: `right-${slug}`,
  };
});

type MatrixEntry = {
  label: string;
  href: string;
};

const collectUnique = (entries: MatrixEntry[]) => {
  const seen = new Map<string, MatrixEntry>();
  entries.forEach((entry) => {
    if (!seen.has(entry.label)) {
      seen.set(entry.label, entry);
    }
  });
  return Array.from(seen.values());
};

const validators = collectUnique(matrix.flatMap((row) => row.validators));
const mechanisms = collectUnique(matrix.flatMap((row) => row.mechanisms));
---

<BaseLayout title={`${pageTitle} â€” Standards`} description={pageDescription} mainClass="page page--wide">
  <PageIntro
    eyebrow="Standards"
    title={pageTitle}
    description={pageDescription}
    permalink={permalink}
    anchorLinks={anchorLinks}
    panelCopy={{
      eyebrow: "Why this exists",
      title: "One lookup table for triage.",
      description:
        "Use this matrix to locate the right validator and mechanism before you open the full standard.",
      link: {
        label: "Open the mapping artifact",
        href: "/standards/std-01-mapping-artifact",
      },
    }}
  />

  <ScholarlyMeta publication={publication} permalink={permalink} />

  <div class="callout">
    <h3>Move fast between rights, validators, and mechanisms</h3>
    <p class="muted">
      Use the full catalogs to jump from each right to diagnostic outputs and enforcement patterns.
    </p>
    <div class="library__role-buttons">
      <a class="button primary library__role-button" href="/validators">
        Run validators
      </a>
      <a class="button primary library__role-button" href="/mechanisms">
        Browse mechanisms
      </a>
      <a
        class="button primary library__role-button"
        href="/standards/std-01-temporal-rights"
      >
        Read STD-01
      </a>
    </div>
  </div>

  <SectionBlock
    id="matrix"
    eyebrow="Crosswalk"
    title="STD-01 rights mapped to validators and mechanisms."
    description="Each row lists the validator coverage and enforcement mechanisms typically used together."
  >
    <div class="glossary-filter rights-matrix__filters" data-matrix-filters>
      <div class="glossary-filter__controls">
        <label class="glossary-filter__facet">
          <span class="glossary-filter__label">STD-01 right</span>
          <select class="glossary-filter__select" name="right" data-matrix-select="right">
            <option value="all">All rights</option>
            {rights.map((right) => (
              <option value={right.slug}>{right.label}</option>
            ))}
          </select>
        </label>
        <label class="glossary-filter__facet">
          <span class="glossary-filter__label">Validator</span>
          <select
            class="glossary-filter__select"
            name="validator"
            data-matrix-select="validator"
          >
            <option value="all">All validators</option>
            {validators.map((validator) => (
              <option value={slugify(validator.label)}>{validator.label}</option>
            ))}
          </select>
        </label>
        <label class="glossary-filter__facet">
          <span class="glossary-filter__label">Mechanism</span>
          <select
            class="glossary-filter__select"
            name="mechanism"
            data-matrix-select="mechanism"
          >
            <option value="all">All mechanisms</option>
            {mechanisms.map((mechanism) => (
              <option value={slugify(mechanism.label)}>{mechanism.label}</option>
            ))}
          </select>
        </label>
        <div class="glossary-filter__actions">
          <button
            class="button secondary glossary-filter__clear"
            type="button"
            data-matrix-reset
          >
            Clear filters
          </button>
        </div>
      </div>
      <p class="glossary-filter__count muted" data-matrix-status aria-live="polite">
        Showing all {matrix.length} rights.
      </p>
      <div class="rights-matrix__jump">
        <span class="glossary-filter__label">Quick jump</span>
        <div class="glossary-filter__chips">
          {rights.map((right) => (
            <a class="glossary-filter__chip" href={`#${right.id}`}>
              {right.label}
            </a>
          ))}
        </div>
      </div>
    </div>
    <div class="mapping-table__wrapper">
      <table class="mapping-table">
        <thead>
          <tr>
            <th scope="col">STD-01 right</th>
            <th scope="col">Validators</th>
            <th scope="col">Mechanisms</th>
            <th scope="col">Coverage note</th>
          </tr>
        </thead>
        <tbody>
          {matrix.map((row, index) => (
            <tr
              id={rights[index].id}
              class="rights-matrix__row"
              data-matrix-row
              data-right={rights[index].slug}
              data-validators={row.validators.map((validator) => slugify(validator.label)).join("|")}
              data-mechanisms={row.mechanisms.map((mechanism) => slugify(mechanism.label)).join("|")}
            >
              <td>
                <strong>{row.right}</strong>
              </td>
              <td>
                <ul>
                  {row.validators.map((validator) => (
                    <li>
                      <a href={validator.href}>{validator.label}</a>
                    </li>
                  ))}
                </ul>
              </td>
              <td>
                <ul>
                  {row.mechanisms.map((mechanism) => (
                    <li>
                      <a href={mechanism.href}>{mechanism.label}</a>
                    </li>
                  ))}
                </ul>
              </td>
              <td>{row.notes}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
    <script>
      const filters = document.querySelector("[data-matrix-filters]");
      if (filters) {
        const selects = Array.from(
          filters.querySelectorAll("[data-matrix-select]"),
        );
        const rows = Array.from(document.querySelectorAll("[data-matrix-row]"));
        const status = filters.querySelector("[data-matrix-status]");
        const reset = filters.querySelector("[data-matrix-reset]");
        const totals = rows.length;
        const state = {
          right: "all",
          validator: "all",
          mechanism: "all",
        };

        const applyFilters = () => {
          const active = Object.values(state).some((value) => value !== "all");
          let visibleCount = 0;

          rows.forEach((row) => {
            if (!(row instanceof HTMLTableRowElement)) return;
            const matchesRight =
              state.right === "all" || row.dataset.right === state.right;
            const matchesValidator =
              state.validator === "all" ||
              row.dataset.validators?.split("|").includes(state.validator);
            const matchesMechanism =
              state.mechanism === "all" ||
              row.dataset.mechanisms?.split("|").includes(state.mechanism);
            const matches = matchesRight && matchesValidator && matchesMechanism;

            row.classList.toggle("is-highlighted", active && matches);
            row.classList.toggle("is-dimmed", active && !matches);
            if (matches) visibleCount += 1;
          });

          if (status) {
            status.textContent = active
              ? `Showing ${visibleCount} of ${totals} rights.`
              : `Showing all ${totals} rights.`;
          }
        };

        selects.forEach((select) => {
          if (!(select instanceof HTMLSelectElement)) return;
          select.addEventListener("change", (event) => {
            const target = event.target;
            if (!(target instanceof HTMLSelectElement)) return;
            const { value } = target;
            const key = target.dataset.matrixSelect;
            if (key === "right") {
              state.right = value;
            } else if (key === "validator") {
              state.validator = value;
            } else if (key === "mechanism") {
              state.mechanism = value;
            }
            applyFilters();
          });
        });

        if (reset) {
          reset.addEventListener("click", () => {
            selects.forEach((select) => {
              if (!(select instanceof HTMLSelectElement)) return;
              select.value = "all";
              const key = select.dataset.matrixSelect;
              if (key === "right") {
                state.right = "all";
              } else if (key === "validator") {
                state.validator = "all";
              } else if (key === "mechanism") {
                state.mechanism = "all";
              }
            });
            applyFilters();
          });
        }
      }
    </script>
  </SectionBlock>

  <SectionBlock
    id="notes"
    eyebrow="Coverage notes"
    title="The matrix is additive, not exhaustive."
    description="Use the minimum binding set and mapping artifact to confirm clause-level coverage."
    variant="alt"
  >
    <ul class="muted">
      <li>
        The same validator may cover multiple rights; use the diagnostics output to confirm specific
        clause gaps.
      </li>
      <li>
        Mechanisms listed here are primary enforcers. Pair them with additional governance or policy
        mechanisms as needed.
      </li>
      <li>
        Review the <a href="/standards/std-01-minimum-binding-set">minimum binding set</a> for
        per-right requirements and insufficiencies.
      </li>
    </ul>
  </SectionBlock>

  <SectionBlock
    id="citations"
    eyebrow="Citations"
    title="Reference this matrix in audits and work plans."
    description="Use the permalink and version to keep audit trails consistent."
  >
    <CitationBlock title={pageTitle} permalink={permalink} publication={publication} />
  </SectionBlock>
</BaseLayout>
