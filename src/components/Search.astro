---
import { Icon } from "astro-icon/components";
---

<div class="search-container">
  <button class="search-trigger" id="search-trigger" aria-label="Open search">
    <Icon name="lucide:search" class="search-icon" />
    <span class="search-label">Search standards...</span>
    <kbd class="search-kbd">/</kbd>
  </button>

  <dialog id="search-dialog" class="search-dialog">
    <div class="search-dialog__header">
      <Icon name="lucide:search" class="search-dialog__icon" />
      <input
        type="text"
        id="search-input"
        placeholder="Search for standards, mechanisms, and validators..."
        autocomplete="off"
      />
      <button
        id="search-close"
        class="search-dialog__close"
        aria-label="Close search"
      >
        <Icon name="lucide:x" />
      </button>
    </div>
    <div id="search-recent" class="search-recent" aria-live="polite" hidden>
      <span class="search-recent__label">Recent:</span>
      <div id="search-recent-list" class="search-recent__list"></div>
    </div>
    <div id="search-results" class="search-results">
      <p class="search-empty">Start typing to search...</p>
    </div>
    <div class="search-dialog__footer">
      <div class="search-help">
        <span><kbd>↑↓</kbd> to navigate</span>
        <span><kbd>↵</kbd> to select</span>
        <span><kbd>esc</kbd> to close</span>
      </div>
      <div class="search-powered">Powered by Pagefind</div>
    </div>
  </dialog>
</div>

<style>
  .search-container {
    position: relative;
    width: 100%;
    max-width: 300px;
  }

  .search-trigger {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    width: 100%;
    padding: 0.5rem 0.75rem;
    background: var(--color-surface-dim, #f8f9fa);
    border: 1px solid var(--color-border, #e9ecef);
    border-radius: 6px;
    color: var(--color-text-muted, #6c757d);
    font-size: 0.875rem;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .search-trigger:hover {
    background: var(--color-surface, #ffffff);
    border-color: var(--color-primary, #007bff);
  }

  .search-icon {
    width: 1rem;
    height: 1rem;
  }

  .search-label {
    flex: 1;
    text-align: left;
  }

  .search-kbd {
    padding: 0.125rem 0.375rem;
    background: var(--color-surface, #ffffff);
    border: 1px solid var(--color-border, #e9ecef);
    border-radius: 4px;
    font-size: 0.75rem;
    font-family: var(--font-mono, monospace);
  }

  .search-dialog {
    width: 90vw;
    max-width: 600px;
    max-height: 80vh;
    padding: 0;
    border: 1px solid var(--color-border, #e9ecef);
    border-radius: 12px;
    box-shadow:
      0 10px 25px -5px rgba(0, 0, 0, 0.1),
      0 8px 10px -6px rgba(0, 0, 0, 0.1);
    background: var(--color-surface, #ffffff);
  }

  .search-dialog::backdrop {
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
  }

  .search-dialog__header {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    border-bottom: 1px solid var(--color-border, #e9ecef);
  }

  .search-dialog__icon {
    width: 1.25rem;
    height: 1.25rem;
    color: var(--color-text-muted, #6c757d);
  }

  .search-dialog input {
    flex: 1;
    border: none;
    background: transparent;
    font-size: 1.125rem;
    outline: none;
  }

  .search-dialog__close {
    padding: 0.5rem;
    background: transparent;
    border: none;
    color: var(--color-text-muted, #6c757d);
    cursor: pointer;
    border-radius: 4px;
  }

  .search-dialog__close:hover {
    background: var(--color-surface-dim, #f8f9fa);
    color: var(--color-text, #212529);
  }

  .search-recent {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem 0;
    flex-wrap: wrap;
  }

  .search-recent__label {
    font-size: 0.75rem;
    color: var(--color-text-muted, #6c757d);
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }

  .search-recent__list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .search-recent__item {
    border: 1px solid var(--color-border, #e9ecef);
    background: var(--color-surface, #ffffff);
    border-radius: 999px;
    padding: 0.25rem 0.75rem;
    font-size: 0.75rem;
    cursor: pointer;
    color: var(--color-text, #212529);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  .search-recent__item:hover,
  .search-recent__item:focus-visible {
    border-color: var(--color-primary, #007bff);
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.15);
    outline: none;
  }

  .search-results {
    min-height: 200px;
    max-height: 50vh;
    overflow-y: auto;
    padding: 1rem;
  }

  .search-empty {
    text-align: center;
    color: var(--color-text-muted, #6c757d);
    margin-top: 3rem;
  }

  .search-dialog__footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    background: var(--color-surface-dim, #f8f9fa);
    border-top: 1px solid var(--color-border, #e9ecef);
    font-size: 0.75rem;
    color: var(--color-text-muted, #6c757d);
  }

  .search-help {
    display: flex;
    gap: 1rem;
  }

  .search-help kbd {
    padding: 0.125rem 0.25rem;
    background: var(--color-surface, #ffffff);
    border: 1px solid var(--color-border, #e9ecef);
    border-radius: 2px;
    font-family: var(--font-mono, monospace);
  }
</style>

<script>
  type PagefindResultData = {
    url: string;
    excerpt: string;
    meta: {
      title: string;
      type?: string;
      section?: string;
      category?: string;
      contentType?: string;
    };
  };

  type PagefindSearchResult = {
    data: () => Promise<PagefindResultData>;
  };

  type PagefindModule = {
    options: (options: { excerptLength: number }) => Promise<void>;
    search: (query: string) => Promise<{ results: PagefindSearchResult[] }>;
  };

  let pagefind: PagefindModule | null;

  async function initPagefind() {
    if (pagefind) return pagefind;
    const pagefindPath = "/pagefind/pagefind.js";
    const loadedPagefind = (await import(
      /* @vite-ignore */
      pagefindPath
    ).catch((error) => {
      console.warn("Pagefind not found. Search may not work in dev mode.", error);
      return null;
    })) as PagefindModule | null;

    if (!loadedPagefind) {
      return null;
    }

    pagefind = loadedPagefind;
    await loadedPagefind.options({
      excerptLength: 20,
    });
    return loadedPagefind;
  }

  const trigger = document.getElementById("search-trigger");
  const dialog = document.getElementById("search-dialog") as HTMLDialogElement;
  const closeBtn = document.getElementById("search-close");
  const input = document.getElementById("search-input") as HTMLInputElement;
  const resultsContainer = document.getElementById("search-results");
  const recentContainer = document.getElementById("search-recent");
  const recentList = document.getElementById("search-recent-list");

  const RECENT_SEARCH_KEY = "et3-search-recent";
  const MAX_RECENT_SEARCHES = 6;
  const GROUP_LABELS = ["Standards", "Validators", "Mechanisms", "Other"];
  const CONTENT_TYPE_MAP: Record<string, string> = {
    standards: "Standards",
    standard: "Standards",
    validators: "Validators",
    validator: "Validators",
    mechanisms: "Mechanisms",
    mechanism: "Mechanisms",
  };
  let activeIndex = -1;
  let currentQuery = "";

  trigger?.addEventListener("click", () => {
    dialog?.showModal();
    initPagefind();
    input?.focus();
    renderRecentSearches();
  });

  closeBtn?.addEventListener("click", () => {
    dialog?.close();
  });

  dialog?.addEventListener("click", (event) => {
    if (event.target === dialog) {
      dialog.close();
    }
  });

  dialog?.addEventListener("close", () => {
    activeIndex = -1;
  });

  document.addEventListener("keydown", (e) => {
    if (
      e.key === "/" &&
      !dialog?.open &&
      document.activeElement?.tagName !== "INPUT" &&
      document.activeElement?.tagName !== "TEXTAREA"
    ) {
      e.preventDefault();
      dialog?.showModal();
      initPagefind();
      input?.focus();
      renderRecentSearches();
    }
  });

  dialog?.addEventListener("keydown", (event) => {
    if (!dialog?.open) return;

    if (event.key === "Escape") {
      event.preventDefault();
      dialog.close();
      trigger?.focus();
      return;
    }

    if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      const items = getResultItems();
      if (items.length === 0) return;

      event.preventDefault();
      const direction = event.key === "ArrowDown" ? 1 : -1;
      const nextIndex =
        activeIndex === -1
          ? direction === 1
            ? 0
            : items.length - 1
          : (activeIndex + direction + items.length) % items.length;

      setActiveIndex(nextIndex, items);
    }

    if (event.key === "Enter") {
      const items = getResultItems();
      if (items.length === 0) return;

      if (activeIndex === -1) {
        setActiveIndex(0, items);
      }

      const activeItem = items[activeIndex];
      if (activeItem) {
        event.preventDefault();
        activeItem.click();
        saveRecentSearch(currentQuery);
      }
    }
  });

  resultsContainer?.addEventListener("focusin", (event) => {
    const target = event.target as HTMLElement | null;
    if (!target?.classList.contains("search-result-item")) return;
    const items = getResultItems();
    activeIndex = items.indexOf(target as HTMLAnchorElement);
    items.forEach((item, index) =>
      item.classList.toggle("is-active", index === activeIndex)
    );
  });

  let debounceTimer: ReturnType<typeof setTimeout> | undefined;
  input?.addEventListener("input", async (event) => {
    const query = (event.target as HTMLInputElement).value;
    currentQuery = query.trim();

    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(async () => {
      await performSearch(currentQuery);
    }, 200);
  });

  function getResultItems() {
    return Array.from(
      resultsContainer?.querySelectorAll<HTMLAnchorElement>(".search-result-item") ??
        []
    );
  }

  function setActiveIndex(index: number, items = getResultItems()) {
    activeIndex = index;
    items.forEach((item, itemIndex) => {
      item.classList.toggle("is-active", itemIndex === activeIndex);
    });
    items[activeIndex]?.focus();
  }

  async function performSearch(query: string) {
    activeIndex = -1;
    if (!query) {
      if (resultsContainer)
        resultsContainer.innerHTML =
          '<p class="search-empty">Start typing to search...</p>';
      return;
    }

    const pf = await initPagefind();
    if (!pf) {
      if (resultsContainer)
        resultsContainer.innerHTML =
          '<p class="search-empty">Search is only available in production builds.</p>';
      return;
    }

    const search = await pf.search(query);
    if (search.results.length === 0) {
      if (resultsContainer)
        resultsContainer.innerHTML = `<p class="search-empty">No results found for "${query}"</p>`;
      return;
    }

    if (resultsContainer) resultsContainer.innerHTML = "";

    const results = await Promise.all(
      search.results
        .slice(0, 12)
        .map((result: PagefindSearchResult) => result.data())
    );

    const groupedResults = groupResultsByType(results);

    groupedResults.forEach(([groupLabel, groupItems]) => {
      const group = document.createElement("div");
      group.className = "search-results-group";
      group.innerHTML = `
        <div class="search-results-heading">${groupLabel}</div>
        <div class="search-results-list"></div>
      `;
      const list = group.querySelector(".search-results-list");

      groupItems.forEach((data) => {
        const item = document.createElement("a");
        item.href = data.url;
        item.className = "search-result-item";
        item.innerHTML = `
          <div class="search-result-content">
            <p class="search-result-title">${data.meta.title}</p>
            <p class="search-result-excerpt">${data.excerpt}</p>
          </div>
        `;
        item.addEventListener("click", () => {
          saveRecentSearch(query);
        });
        list?.appendChild(item);
      });

      resultsContainer?.appendChild(group);
    });
  }

  function groupResultsByType(results: PagefindResultData[]) {
    const grouped = new Map<string, PagefindResultData[]>();

    results.forEach((data) => {
      const label = resolveContentTypeLabel(data.meta) ?? "Other";
      const bucket = grouped.get(label) ?? [];
      bucket.push(data);
      grouped.set(label, bucket);
    });

    return GROUP_LABELS.flatMap((label) =>
      grouped.has(label) ? [[label, grouped.get(label)!] as const] : []
    );
  }

  function resolveContentTypeLabel(meta: PagefindResultData["meta"]) {
    const rawType = (
      meta.type ??
      meta.contentType ??
      meta.category ??
      meta.section ??
      ""
    )
      .toString()
      .trim()
      .toLowerCase();
    return CONTENT_TYPE_MAP[rawType] ?? null;
  }

  function loadRecentSearches() {
    if (typeof localStorage === "undefined") return [];
    const stored = localStorage.getItem(RECENT_SEARCH_KEY);
    if (!stored) return [];
    try {
      const parsed = JSON.parse(stored);
      if (Array.isArray(parsed)) {
        return parsed.filter((item) => typeof item === "string");
      }
    } catch (error) {
      console.warn("Unable to parse recent searches", error);
    }
    return [];
  }

  function saveRecentSearch(query: string) {
    const trimmed = query.trim();
    if (!trimmed || typeof localStorage === "undefined") return;
    const current = loadRecentSearches().filter((item) => item !== trimmed);
    current.unshift(trimmed);
    const next = current.slice(0, MAX_RECENT_SEARCHES);
    localStorage.setItem(RECENT_SEARCH_KEY, JSON.stringify(next));
    renderRecentSearches(next);
  }

  function renderRecentSearches(recent = loadRecentSearches()) {
    if (!recentContainer || !recentList) return;

    recentList.innerHTML = "";
    if (recent.length === 0) {
      recentContainer.hidden = true;
      return;
    }

    recentContainer.hidden = false;
    recent.forEach((term) => {
      const button = document.createElement("button");
      button.type = "button";
      button.className = "search-recent__item";
      button.textContent = term;
      button.addEventListener("click", () => {
        input.value = term;
        currentQuery = term;
        input.focus();
        performSearch(term);
      });
      recentList.appendChild(button);
    });
  }
</script>

<style is:global>
  .search-result-item {
    display: block;
    padding: 0.75rem;
    border-radius: 6px;
    text-decoration: none;
    color: inherit;
    transition: background 0.2s ease;
    margin-bottom: 0;
  }

  .search-result-item:hover {
    background: var(--color-surface-dim, #f8f9fa);
  }

  .search-result-item:focus-visible,
  .search-result-item.is-active {
    background: var(--color-surface-dim, #f8f9fa);
    outline: 2px solid var(--color-primary, #007bff);
    outline-offset: 2px;
  }

  .search-results-group {
    margin-bottom: 1rem;
  }

  .search-results-heading {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--color-text-muted, #6c757d);
    margin-bottom: 0.5rem;
  }

  .search-results-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .search-result-title {
    font-weight: 600;
    margin-bottom: 0.25rem;
    color: var(--color-primary, #007bff);
  }

  .search-result-excerpt {
    font-size: 0.8125rem;
    color: var(--color-text-muted, #6c757d);
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .search-result-excerpt mark {
    background: rgba(255, 193, 7, 0.3);
    color: inherit;
    border-radius: 2px;
    padding: 0 0.125rem;
  }
</style>
