---
import { Icon } from "astro-icon/components";
---

<div class="search-container">
  <button
    class="search-trigger"
    id="search-trigger"
    type="button"
    aria-label="Open search"
  >
    <Icon name="lucide:search" class="search-icon" />
    <span class="search-label">Search standards...</span>
    <kbd class="search-kbd">/</kbd>
  </button>

  <dialog
    id="search-dialog"
    class="search-dialog"
    aria-labelledby="search-dialog-title"
  >
    <div class="search-dialog__header">
      <Icon name="lucide:search" class="search-dialog__icon" />
      <span id="search-dialog-title" class="visually-hidden">
        Site search
      </span>
      <search class="search-dialog__search" role="search">
        <label class="search-dialog__label" for="search-input">
          <span class="visually-hidden">Search the library</span>
          <input
            type="search"
            id="search-input"
            placeholder="Search for standards, mechanisms, and validators..."
            autocomplete="off"
            enterkeyhint="search"
            aria-describedby="search-help-text"
          />
        </label>
      </search>
      <button
        id="search-close"
        class="search-dialog__close"
        type="button"
        aria-label="Close search"
      >
        <Icon name="lucide:x" />
      </button>
    </div>
    <div id="search-recent" class="search-recent" aria-live="polite" hidden>
      <span class="search-recent__label">Recent:</span>
      <div id="search-recent-list" class="search-recent__list"></div>
    </div>
    <div id="search-results" class="search-results">
      <p class="search-empty">Start typing to search...</p>
    </div>
    <div class="search-dialog__footer">
      <p id="search-help-text" class="visually-hidden">
        Search standards, mechanisms, validators, research, and glossary
        entries.
      </p>
      <div class="search-help">
        <span><kbd>↑↓</kbd> to navigate</span>
        <span><kbd>↵</kbd> to select</span>
        <span><kbd>esc</kbd> to close</span>
      </div>
      <div class="search-powered">Powered by Pagefind</div>
    </div>
  </dialog>
</div>

<style>
  .search-container {
    position: relative;
    width: 100%;
    max-width: 300px;
  }

  .search-trigger {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    width: 100%;
    min-height: 44px;
    padding: 0.55rem 0.75rem;
    background: color-mix(in srgb, var(--surface) 94%, white 6%);
    border: 1px solid color-mix(in srgb, var(--border) 80%, transparent);
    border-radius: 6px;
    color: var(--muted);
    font-size: 0.95rem;
    line-height: 1.2;
    cursor: pointer;
    touch-action: manipulation;
    transition:
      background-color 0.2s ease,
      border-color 0.2s ease,
      box-shadow 0.2s ease,
      color 0.2s ease,
      transform 0.2s ease;
  }

  .search-trigger:hover {
    background: color-mix(in srgb, var(--surface) 98%, white 2%);
    border-color: color-mix(in srgb, var(--accent) 45%, var(--border));
  }

  .search-trigger:focus-visible {
    outline: 2px solid var(--gold);
    outline-offset: 2px;
    border-color: var(--gold);
    background: linear-gradient(
      120deg,
      color-mix(in srgb, var(--surface) 98%, white 2%),
      color-mix(in srgb, var(--gold) 15%, transparent)
    );
    box-shadow:
      0 4px 12px rgba(168, 132, 79, 0.15),
      0 0 0 2px var(--gold);
    transform: scale(1.02);
  }

  .search-icon {
    width: 1rem;
    height: 1rem;
  }

  .search-label {
    flex: 1;
    text-align: left;
  }

  .search-kbd {
    padding: 0.125rem 0.375rem;
    background: color-mix(in srgb, var(--surface) 96%, white 4%);
    border: 1px solid color-mix(in srgb, var(--border) 75%, transparent);
    border-radius: 4px;
    font-size: 0.75rem;
    font-family: var(--mono);
  }

  .search-dialog {
    width: 90vw;
    max-width: 600px;
    max-height: 80vh;
    padding: 0;
    border: 1px solid color-mix(in srgb, var(--border) 80%, transparent);
    border-radius: 12px;
    box-shadow:
      0 12px 26px rgba(42, 38, 33, 0.18),
      0 6px 12px rgba(42, 38, 33, 0.12);
    background: var(--surface);
  }

  .search-dialog::backdrop {
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
  }

  .search-dialog__header {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    border-bottom: 1px solid color-mix(in srgb, var(--border) 75%, transparent);
  }

  .search-dialog__icon {
    width: 1.25rem;
    height: 1.25rem;
    color: var(--muted);
  }

  .search-dialog__search {
    flex: 1;
    margin: 0;
  }

  .search-dialog__label {
    display: flex;
    width: 100%;
  }

  .search-dialog__search input {
    width: 100%;
    flex: 1;
    border: none;
    background: transparent;
    font-size: 1.125rem;
    outline: 2px solid transparent;
    outline-offset: 2px;
    color: var(--text);
    font-family: var(--serif);
    padding: 0.35rem 0.25rem;
    border-radius: 8px;
  }

  .search-dialog__search input::placeholder {
    color: color-mix(in srgb, var(--muted) 80%, transparent);
  }

  .search-dialog__search input:focus-visible {
    outline: 2px solid var(--accent-strong);
    outline-offset: 2px;
    box-shadow: 0 0 0 6px color-mix(in srgb, var(--accent) 22%, transparent);
    background: color-mix(in srgb, var(--surface) 96%, white 4%);
  }

  .search-dialog__close {
    padding: 0.5rem;
    min-width: 44px;
    min-height: 44px;
    background: transparent;
    border: none;
    color: var(--muted);
    cursor: pointer;
    border-radius: 4px;
    touch-action: manipulation;
  }

  .search-dialog__close:hover {
    background: color-mix(in srgb, var(--surface) 94%, white 6%);
    color: var(--text);
  }

  .search-dialog__close:focus-visible {
    outline: 2px solid var(--accent-strong);
    outline-offset: 2px;
    box-shadow: 0 0 0 6px color-mix(in srgb, var(--accent) 22%, transparent);
  }

  .search-recent {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem 0;
    flex-wrap: wrap;
  }

  .search-recent__label {
    font-size: 0.75rem;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }

  .search-recent__list {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .search-recent__item {
    border: 1px solid color-mix(in srgb, var(--border) 75%, transparent);
    background: color-mix(in srgb, var(--surface) 96%, white 4%);
    border-radius: 999px;
    padding: 0.25rem 0.75rem;
    font-size: 0.75rem;
    cursor: pointer;
    color: var(--text);
    min-height: 44px;
    touch-action: manipulation;
    transition:
      border-color 0.2s ease,
      box-shadow 0.2s ease;
  }

  .search-recent__item:hover,
  .search-recent__item:focus-visible {
    border-color: color-mix(in srgb, var(--accent) 50%, var(--border));
    box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent) 18%, transparent);
    outline: 2px solid var(--accent-strong);
    outline-offset: 2px;
  }

  .search-results {
    min-height: 200px;
    max-height: 50vh;
    overflow-y: auto;
    padding: 1rem;
    overscroll-behavior: contain;
  }

  .search-empty {
    text-align: center;
    color: var(--muted);
    margin-top: 3rem;
  }

  .search-suggestions {
    margin-top: 1rem;
    font-size: 0.85rem;
    color: var(--muted);
    line-height: 1.6;
  }

  .search-dialog__footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    background: color-mix(in srgb, var(--surface) 92%, white 8%);
    border-top: 1px solid color-mix(in srgb, var(--border) 75%, transparent);
    font-size: 0.75rem;
    color: var(--muted);
  }

  .search-help {
    display: flex;
    gap: 1rem;
  }

  .search-help kbd {
    padding: 0.125rem 0.25rem;
    background: color-mix(in srgb, var(--surface) 96%, white 4%);
    border: 1px solid color-mix(in srgb, var(--border) 75%, transparent);
    border-radius: 2px;
    font-family: var(--mono);
  }
</style>

<script>
  type PagefindResultData = {
    url: string;
    excerpt: string;
    meta: {
      title: string;
      type?: string;
      section?: string;
      category?: string;
      contentType?: string;
    };
  };

  type PagefindSearchResult = {
    data: () => Promise<PagefindResultData>;
  };

  type PagefindModule = {
    options: (options: { excerptLength: number }) => Promise<void>;
    search: (query: string) => Promise<{ results: PagefindSearchResult[] }>;
  };

  let pagefind: PagefindModule | null;

  async function initPagefind() {
    if (pagefind) return pagefind;
    const pagefindPath = "/pagefind/pagefind.js";
    const loadedPagefind = (await import(
      /* @vite-ignore */
      pagefindPath
    ).catch((error) => {
      console.warn(
        "Pagefind not found. Search may not work in dev mode.",
        error
      );
      return null;
    })) as PagefindModule | null;

    if (!loadedPagefind) {
      return null;
    }

    pagefind = loadedPagefind;
    await loadedPagefind.options({
      excerptLength: 20,
    });
    return loadedPagefind;
  }

  const trigger = document.getElementById("search-trigger");
  const dialog = document.getElementById("search-dialog") as HTMLDialogElement;
  const closeBtn = document.getElementById("search-close");
  const input = document.getElementById("search-input") as HTMLInputElement;
  const resultsContainer = document.getElementById("search-results");
  const recentContainer = document.getElementById("search-recent");
  const recentList = document.getElementById("search-recent-list");

  const RECENT_SEARCH_KEY = "et3-search-recent";
  const SEARCH_QUERY_STORAGE_KEY = "et3-search-query";
  const MAX_RECENT_SEARCHES = 6;
  const GROUP_LABELS = ["Standards", "Validators", "Mechanisms", "Other"];
  const SEARCH_MODAL_PARAM = "modal";
  const SEARCH_QUERY_PARAM = "q";
  const CONTENT_TYPE_MAP: Record<string, string> = {
    standards: "Standards",
    standard: "Standards",
    validators: "Validators",
    validator: "Validators",
    mechanisms: "Mechanisms",
    mechanism: "Mechanisms",
  };
  let activeIndex = -1;
  let currentQuery = "";

  function openDialog({ pushHistory = true } = {}) {
    if (!dialog || dialog.open) return;
    dialog.showModal();
    initPagefind();
    input?.focus();
    renderRecentSearches();

    if (pushHistory) {
      const url = new URL(window.location.href);
      url.searchParams.set(SEARCH_MODAL_PARAM, "search");
      if (currentQuery) {
        url.searchParams.set(SEARCH_QUERY_PARAM, currentQuery);
      } else {
        url.searchParams.delete(SEARCH_QUERY_PARAM);
      }
      history.pushState({ modal: "search" }, "", url);
    }
  }

  function closeDialog({ fromHistory = false } = {}) {
    if (!dialog?.open) return;
    dialog.close();

    if (fromHistory) return;

    const url = new URL(window.location.href);
    url.searchParams.delete(SEARCH_MODAL_PARAM);
    if (!currentQuery) {
      url.searchParams.delete(SEARCH_QUERY_PARAM);
    }
    history.replaceState(history.state ?? {}, "", url);
  }

  function requestDialogClose() {
    if (!dialog?.open) return;
    if (history.state?.modal === "search") {
      history.back();
      return;
    }
    closeDialog();
  }

  function updateQueryParam(query: string) {
    const url = new URL(window.location.href);
    if (dialog?.open) {
      url.searchParams.set(SEARCH_MODAL_PARAM, "search");
    }
    if (query) {
      url.searchParams.set(SEARCH_QUERY_PARAM, query);
    } else {
      url.searchParams.delete(SEARCH_QUERY_PARAM);
    }
    history.replaceState(history.state ?? {}, "", url);
    if (typeof sessionStorage !== "undefined") {
      if (query) {
        sessionStorage.setItem(SEARCH_QUERY_STORAGE_KEY, query);
      } else {
        sessionStorage.removeItem(SEARCH_QUERY_STORAGE_KEY);
      }
    }
  }

  function loadStoredQuery() {
    if (typeof sessionStorage === "undefined") return "";
    return sessionStorage.getItem(SEARCH_QUERY_STORAGE_KEY) ?? "";
  }

  function syncDialogWithUrl() {
    const params = new URLSearchParams(window.location.search);
    const shouldOpen = params.get(SEARCH_MODAL_PARAM) === "search";
    const query = params.get(SEARCH_QUERY_PARAM) ?? "";

    let resolvedQuery = query;
    if (shouldOpen && !query) {
      resolvedQuery = loadStoredQuery();
      if (resolvedQuery) {
        updateQueryParam(resolvedQuery);
      }
    }

    if (input) {
      input.value = resolvedQuery;
    }
    currentQuery = resolvedQuery.trim();

    if (shouldOpen && !dialog?.open) {
      openDialog({ pushHistory: false });
    }

    if (!shouldOpen && dialog?.open) {
      closeDialog({ fromHistory: true });
    }

    if (shouldOpen) {
      if (currentQuery) {
        performSearch(currentQuery);
      } else if (resultsContainer) {
        resultsContainer.innerHTML =
          '<p class="search-empty">Start typing to search...</p>';
      }
    }
  }

  trigger?.addEventListener("click", () => {
    openDialog();
  });

  closeBtn?.addEventListener("click", () => {
    requestDialogClose();
  });

  dialog?.addEventListener("click", (event) => {
    if (event.target === dialog) {
      requestDialogClose();
    }
  });

  dialog?.addEventListener("close", () => {
    activeIndex = -1;
    trigger?.focus();
  });

  document.addEventListener("keydown", (e) => {
    if (
      e.key === "/" &&
      !dialog?.open &&
      document.activeElement?.tagName !== "INPUT" &&
      document.activeElement?.tagName !== "TEXTAREA"
    ) {
      e.preventDefault();
      openDialog();
    }
  });

  dialog?.addEventListener("keydown", (event) => {
    if (!dialog?.open) return;

    if (event.key === "Escape") {
      event.preventDefault();
      requestDialogClose();
      return;
    }

    if (event.key === "ArrowDown" || event.key === "ArrowUp") {
      const items = getResultItems();
      if (items.length === 0) return;

      event.preventDefault();
      const direction = event.key === "ArrowDown" ? 1 : -1;
      const nextIndex =
        activeIndex === -1
          ? direction === 1
            ? 0
            : items.length - 1
          : (activeIndex + direction + items.length) % items.length;

      setActiveIndex(nextIndex, items);
    }

    if (event.key === "Enter") {
      const items = getResultItems();
      if (items.length === 0) return;

      if (activeIndex === -1) {
        setActiveIndex(0, items);
      }

      const activeItem = items[activeIndex];
      if (activeItem) {
        event.preventDefault();
        activeItem.click();
        saveRecentSearch(currentQuery);
      }
    }
  });

  resultsContainer?.addEventListener("focusin", (event) => {
    const target = event.target as HTMLElement | null;
    if (!target?.classList.contains("search-result-item")) return;
    const items = getResultItems();
    activeIndex = items.indexOf(target as HTMLAnchorElement);
    items.forEach((item, index) =>
      item.classList.toggle("is-active", index === activeIndex)
    );
  });

  let debounceTimer: ReturnType<typeof setTimeout> | undefined;
  input?.addEventListener("input", async (event) => {
    const query = (event.target as HTMLInputElement).value;
    currentQuery = query.trim();
    updateQueryParam(currentQuery);
    activeIndex = -1;

    if (resultsContainer) {
      resultsContainer.innerHTML = currentQuery
        ? '<p class="search-empty">Searching...</p>'
        : '<p class="search-empty">Start typing to search...</p>';
    }

    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(async () => {
      await performSearch(currentQuery);
    }, 200);
  });

  function getResultItems() {
    return Array.from(
      resultsContainer?.querySelectorAll<HTMLAnchorElement>(
        ".search-result-item"
      ) ?? []
    );
  }

  function setActiveIndex(index: number, items = getResultItems()) {
    activeIndex = index;
    items.forEach((item, itemIndex) => {
      item.classList.toggle("is-active", itemIndex === activeIndex);
    });
    items[activeIndex]?.focus();
  }

  async function performSearch(query: string) {
    activeIndex = -1;
    if (!query) {
      if (resultsContainer)
        resultsContainer.innerHTML =
          '<p class="search-empty">Start typing to search...</p>';
      return;
    }

    if (resultsContainer)
      resultsContainer.innerHTML = '<p class="search-empty">Searching...</p>';

    const pf = await initPagefind();
    if (!pf) {
      if (resultsContainer)
        resultsContainer.innerHTML =
          '<p class="search-empty">Search is only available in production builds.</p>';
      return;
    }

    const search = await pf.search(query);
    if (search.results.length === 0) {
      if (resultsContainer)
        resultsContainer.innerHTML = `
          <div class="search-empty">
            <p>No results found for "<strong>${query}</strong>"</p>
            <p class="search-suggestions">
              Suggestions:<br/>
              • Check for typos<br/>
              • Try broader terms like "standard" or "validator"<br/>
              • Search for specific ID (e.g., "STD-01")
            </p>
          </div>
        `;
      return;
    }

    if (resultsContainer) resultsContainer.innerHTML = "";

    const results = await Promise.all(
      search.results
        .slice(0, 12)
        .map((result: PagefindSearchResult) => result.data())
    );

    const groupedResults = groupResultsByType(results);

    groupedResults.forEach(([groupLabel, groupItems]) => {
      const group = document.createElement("div");
      group.className = "search-results-group";
      group.innerHTML = `
        <div class="search-results-heading">${groupLabel}</div>
        <div class="search-results-list"></div>
      `;
      const list = group.querySelector(".search-results-list");

      groupItems.forEach((data) => {
        const item = document.createElement("a");
        item.href = data.url;
        item.className = "search-result-item";
        item.innerHTML = `
          <div class="search-result-content">
            <p class="search-result-title">${data.meta.title}</p>
            <p class="search-result-excerpt">${data.excerpt}</p>
          </div>
        `;
        item.addEventListener("click", () => {
          saveRecentSearch(query);
        });
        list?.appendChild(item);
      });

      resultsContainer?.appendChild(group);
    });
  }

  function groupResultsByType(results: PagefindResultData[]) {
    const grouped = new Map<string, PagefindResultData[]>();

    results.forEach((data) => {
      const label = resolveContentTypeLabel(data.meta) ?? "Other";
      const bucket = grouped.get(label) ?? [];
      bucket.push(data);
      grouped.set(label, bucket);
    });

    return GROUP_LABELS.flatMap((label) =>
      grouped.has(label) ? [[label, grouped.get(label)!] as const] : []
    );
  }

  function resolveContentTypeLabel(meta: PagefindResultData["meta"]) {
    const rawType = (
      meta.type ??
      meta.contentType ??
      meta.category ??
      meta.section ??
      ""
    )
      .toString()
      .trim()
      .toLowerCase();
    return CONTENT_TYPE_MAP[rawType] ?? null;
  }

  function loadRecentSearches() {
    if (typeof localStorage === "undefined") return [];
    const stored = localStorage.getItem(RECENT_SEARCH_KEY);
    if (!stored) return [];
    try {
      const parsed = JSON.parse(stored);
      if (Array.isArray(parsed)) {
        return parsed.filter((item) => typeof item === "string");
      }
    } catch (error) {
      console.warn("Unable to parse recent searches", error);
    }
    return [];
  }

  function saveRecentSearch(query: string) {
    const trimmed = query.trim();
    if (!trimmed || typeof localStorage === "undefined") return;
    const current = loadRecentSearches().filter((item) => item !== trimmed);
    current.unshift(trimmed);
    const next = current.slice(0, MAX_RECENT_SEARCHES);
    localStorage.setItem(RECENT_SEARCH_KEY, JSON.stringify(next));
    renderRecentSearches(next);
  }

  function renderRecentSearches(recent = loadRecentSearches()) {
    if (!recentContainer || !recentList) return;

    recentList.innerHTML = "";
    if (recent.length === 0) {
      recentContainer.hidden = true;
      return;
    }

    recentContainer.hidden = false;
    recent.forEach((term) => {
      const button = document.createElement("button");
      button.type = "button";
      button.className = "search-recent__item";
      button.textContent = term;
      button.addEventListener("click", () => {
        input.value = term;
        currentQuery = term;
        updateQueryParam(currentQuery);
        input.focus();
        performSearch(term);
      });
      recentList.appendChild(button);
    });
  }

  window.addEventListener("popstate", () => {
    syncDialogWithUrl();
  });

  syncDialogWithUrl();
</script>

<style is:global>
  .search-result-item {
    display: block;
    padding: 0.75rem;
    min-height: 44px;
    border-radius: 6px;
    text-decoration: none;
    color: inherit;
    touch-action: manipulation;
    transition: background 0.2s ease;
    margin-bottom: 0;
  }

  .search-result-item:hover {
    background: color-mix(in srgb, var(--surface) 94%, white 6%);
  }

  .search-result-item:focus-visible,
  .search-result-item.is-active {
    background: color-mix(in srgb, var(--surface) 94%, white 6%);
    outline: 2px solid var(--accent-strong);
    outline-offset: 2px;
  }

  .search-results-group {
    margin-bottom: 1rem;
  }

  .search-results-heading {
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--muted);
    margin-bottom: 0.5rem;
  }

  .search-results-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .search-result-title {
    font-weight: 600;
    margin-bottom: 0.25rem;
    color: var(--accent);
  }

  .search-result-excerpt {
    font-size: 0.8125rem;
    color: var(--muted);
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .search-result-excerpt mark {
    background: color-mix(in srgb, var(--gold) 30%, transparent);
    color: inherit;
    border-radius: 2px;
    padding: 0 0.125rem;
  }
</style>
